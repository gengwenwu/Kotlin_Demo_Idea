package org.logan.test.kotlin.basic.cp09.ext932

/**
 * desc: 类、类型和子类型 <br/>
 *
 * time: 2020/1/10 3:01 下午 <br/>
 * author: Logan <br/>
 * since V 1.0 <br/>
 */

// 有时候我们会把类型和类当成同样的概念使用，但它们不一样的，现在看看它们区别。
// 最简单的例子就是非泛型类，类的名称可以直接当作类型使用。如下：
//      var x : String   // 非空
//      var x : String?  // 可空，这意味着每一个 Kotlin类 都可以用于构造至少两种类型。

// 泛型类的情况就变得更复杂了。要得到一个合法的类型，需要用一个作为类型实参的具体类型替换(泛型)类的类型形参。
// List 不是一个类型 (它是一个类)，但是下面列举出来的所有替代品都是合法的类型:
// List<Int>、 List<String?>、 List<List<String>>等。每一个泛型类都可能生成潜在的无限数量的类型。


// 为了讨论类型之间的关系，需要熟悉子类型这个术语。
// 任何时候，如果需要的是类型 A 的值，你都能够使用类型 B 的值 (当作 A的值)，类型 B 就称为类型 A 的子类型。譬如：
// Int 是 Number 的子类型，但 Int 不是 String 的子类型。
// 这个定义还表明了任何类型都可以被认为是它自己的子类型。

// 术语 超类型 是子类型的反义词，如果 A 是 B 的子类型，那么 B 就是 A 的超类型。

// 为什么一个类型是否是另一个的子类型这么重要？编译器在每一次给变量赋值 或者 给函数传递实参的时候，都要做这项检查。
// 只有值的类型是变量类型的子类型时，才允许变量存储该值。如下：
fun test(i: Int) {
    val n: Number = i // 编译可以通过，因为Int是Number的子类型。

    fun f(s: String) {}
    // f(i) // 编译错误，int不是String的子类型
}

// 简单的情况下，子类型和子类本质上意味着一样的事物。例如，Int 类是 Number的子类，因此 Int 类型是 Number 类型的子类型。
// 如果一个类实现了一个接口，它的类型就是该接口类型的子类型 : String 是 CharSequence 的子类型。


// 可空类型提供了一个例子，
// 说明子类型和子类不是同一个事物： 非空类型 A 是可空的 A? 的子类型，但反过来却不是。
// 你不能将 A? 赋值给 A 类型，但它们都对应着同一个类。
fun test2() {
    val s: String = "abc"
    val t: String? = s // 赋值合法，因为 String 是 String? 子类型
}


// 当我们开始涉及泛型类型时，子类型和子类之间的差异显得格外重要。
// 把 List<String> 类型的变量传给期望 List<Any> 的函数是否安全？现在可以使用子类型化术语来重新组织:
// List<String> 是 List<Any> 的子类型吗? MutableList<String> 是 MutableList<Any> 子类型吗？
// 其实都不是！但是对于 List 来说，子类型化规则不一样。 Kotlin 中的 List 接口表示的是只读集合。
// 如果 A 是 B 的子类型，那么 List<A> 就是 List<B> 的子类型。这样的类或者接口被称为协变的。后面章节会细讲。

// 一个泛型类 一一 例如， MutableList 一一 如果对于任意两种类型 A 和 B，
// MutableList<A> 既不是 MutableList<B> 的子类型，也不是它的超类型，它就被称为在该类型参数上是不变型的。
// Java中所有的类都是不变型的
